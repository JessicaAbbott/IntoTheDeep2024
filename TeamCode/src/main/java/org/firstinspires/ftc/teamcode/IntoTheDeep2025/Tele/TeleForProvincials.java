package org.firstinspires.ftc.teamcode.IntoTheDeep2025.Tele;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.config.Config;
import com.acmerobotics.dashboard.telemetry.MultipleTelemetry;
import com.arcrobotics.ftclib.controller.PIDController;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.Odometry.SimplifiedOdometryRobot.SimplifiedOdometryRobot;

@TeleOp
@Config
public class TeleForProvincials extends LinearOpMode{

   public CRServo intakeLeft;
   public CRServo intakeRight;
   public Servo intakeServo;

   public Servo climbServo;
   public DcMotor climbHook;
   private PIDController armController;

   boolean climbButtonPressed = false;

   boolean climbServoPressed = false;

   // PID constants
   public static double p = 0.035, i = 0.0, d = 0.002;  // Tuning constants for PID controller
   public static double f = 0.1;  // Feedforward constant

   private final double ticks_in_degree = 8192 / 360.0;  // Encoder ticks per degree

   private DcMotorEx armPivot;
   private double target = 0;  // Initial target position for the arm

   double newTarget = 0;

   final double SAFE_DRIVE_SPEED = 1.0;
   final double SAFE_STRAFE_SPEED = 1.0;
   final double SAFE_YAW_SPEED = 1.0;
   final double HEADING_HOLD_TIME = 10.0;

   ElapsedTime stopTime = new ElapsedTime();
   boolean autoHeading = false;

   long lastTime = System.nanoTime();

   private double lastLF = 0.0;
   private double lastLB = 0.0;
   private double lastRF = 0.0;
   private double lastRB = 0.0;

    private DcMotorEx armExtension1;
   private DcMotorEx armExtension2;

   SimplifiedOdometryRobot robot = new SimplifiedOdometryRobot(this);

   private ElapsedTime timer = new ElapsedTime();  // Create a timer


   @Override
   public void runOpMode() throws InterruptedException {

      telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());

      intakeLeft = hardwareMap.get(CRServo.class, "intakeLeft");
      intakeLeft.setDirection(CRServo.Direction.FORWARD);

      intakeRight = hardwareMap.get(CRServo.class, "intakeRight");
      intakeRight.setDirection(CRServo.Direction.REVERSE);

      intakeServo = hardwareMap.get(Servo.class, "intakeServo");

      climbServo = hardwareMap.get(Servo.class, "climbServo");

      armController = new PIDController(p, i, d);
      telemetry = new MultipleTelemetry(telemetry, FtcDashboard.getInstance().getTelemetry());

      armPivot = hardwareMap.get(DcMotorEx.class, "armPivot");
      armPivot.setDirection(DcMotorSimple.Direction.REVERSE);
      armPivot.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
      armPivot.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);

      armExtension1=hardwareMap.get(DcMotorEx.class,"armExtension");
      armExtension1.setDirection(DcMotorSimple.Direction.FORWARD);
       armExtension1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);


      armExtension2=hardwareMap.get(DcMotorEx.class,"lateral");
      armExtension2.setDirection(DcMotorSimple.Direction.REVERSE);
       armExtension2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

      climbHook = hardwareMap.get(DcMotor.class, "axial");
      climbHook.setDirection(DcMotorSimple.Direction.FORWARD);
      climbHook.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

      robot.initialize(true);

      while (opModeInInit()) {
         robot.readSensors();
         telemetry.update();
       }

      while (opModeIsActive()) {
         robot.readSensors();
         long currentTime = System.nanoTime();


         if (gamepad1.a) {
            //robot.setPos(36,9,0);
            robot.resetHeading();
         }

         // read joystick values and scale according to limits set at top of this file
         double drive = gamepad1.right_stick_x * SAFE_DRIVE_SPEED;
         double strafe = -gamepad1.right_stick_y * SAFE_STRAFE_SPEED;
         double yaw =  gamepad1.left_stick_x * SAFE_YAW_SPEED;

         // Drive the robot
         robot.driveWithFieldCentric(drive, strafe, yaw);

         // If auto heading is on, override manual yaw with the value generated by the heading controller.
         if (autoHeading) {
            yaw = robot.yawController.getOutput(robot.getHeading());
         }

         // arm
         // Update the arm pivot position using PID control
         if (gamepad2.b) {
            target = 84; // low basket pos
            newTarget = 84;
         } else if (gamepad2.y) {
            target = 127;
            newTarget = 127;

         } else if (gamepad2.dpad_down) {

            target = 35;  //ideally height just below specimen hugh bar for  specimen hooking
            newTarget = 35;
         } else if (gamepad2.dpad_up) {
            target = 56;
            newTarget = 56;
         } else if (gamepad2.a) {
            target = 15;
            newTarget = 15;
         } else if (gamepad2.dpad_left) {
            newTarget = target - 10;
         } else if (gamepad2.dpad_right) {
            newTarget = target + 10;
         }
         else {
            target = newTarget;
         }

         // intake

         if (gamepad2.left_bumper) { // out
            intakeLeft.setPower(-0.9);
            intakeRight.setPower(-0.9);
         } else if (gamepad2.right_bumper) {
            //continue in and move servo out of way
            intakeServo.setPosition(1.0);
            intakeLeft.setPower(0.6);
            intakeRight.setPower(0.6);
         }
         else if (gamepad2.left_trigger>0){
            intakeLeft.setPower(1);
            intakeRight.setPower(1);
         }
         else if (gamepad2.right_trigger > 0) { //
            // in// down to pick up
            intakeServo.setPosition(0.5); // this is changed so it will ideally not jam
            intakeLeft.setPower(1);
            intakeRight.setPower(1);
            target = 2;
         }

         else {
            intakeServo.setPosition(0.5);
            intakeRight.setPower(0);
            intakeLeft.setPower(0);
         }

         // Arm extension control
         if (gamepad2.left_stick_y < 0) {
            armExtension1.setPower(1);
            armExtension2.setPower(1);
         }

         else if (gamepad2.left_stick_y > 0) {
            armExtension1.setPower(-1);
            armExtension2.setPower(-1);
         }

         else {
            armExtension1.setPower(0);
            armExtension2.setPower(0);
         }

         // climbHook

         if (gamepad1.left_trigger>0){
            //down
            climbHook.setPower(1);
         } else if (gamepad1.right_trigger > 0) {
            //up
            climbHook.setPower(-1);
         }

         // climb servo position tests

         //if (gamepad1.y){
         //   climbServo.setPosition(0.65);// perfect away position
         // }

        // climb automation button
         if (gamepad1.x){
            climbButtonPressed=true;

            if(climbButtonPressed=true){
               climbHook.setPower(0);
               extensionIn();
               waitFor(800);
               setArmTarget(138);
               runArmPID();
               fullExtension();
               waitFor(2500);
               climbServo.setPosition(0.275);
               stopExtension();
               waitFor(200);
               firstAscent(); // get it to pull up a bit farther so that the hook can get over
               climbHook.setPower(0.2);
               setArmTarget(142);
               runArmPID();
               fullExtension();
               waitFor(1000);
               stopExtension();
               retractToHook();
               waitFor(2000);
               stopExtension();
               ClimbHookRelease();

               setArmTarget(-23);
               runArmPID();

               fullRetraction();
               waitFor(6000);
               holdPosition();
               stop();
            }

            else if (gamepad1.options){
               climbButtonPressed=false;
               break;
            }
         }

         else {climbButtonPressed=false;}

         double armPos = -armPivot.getCurrentPosition() / ticks_in_degree;  // Convert encoder ticks to degrees
         double armPidOutput = armController.calculate(armPos, target);  // Calculate PID output
         double armff = Math.cos(Math.toRadians(target)) * f;  // Feedforward term
         double armPower = armPidOutput + armff;  // Final motor armPower (PID + Feedforward)

         armPower = Math.max(-0.4, Math.min(1.75, armPower));

         armPivot.setPower(armPower);  // Set motor armPower to the calculated value

         double currentLF = robot.LFMotor.getCurrentPosition() * 0.0012186958;
         double currentLB = robot.LBMotor.getCurrentPosition() * 0.0012186958;
         double currentRF = robot.RFMotor.getCurrentPosition() * 0.0012186958;
         double currentRB = robot.RBMotor.getCurrentPosition() * 0.0012186958;
         double loopTime = (currentTime-lastTime) / 1E9;

         telemetry.addData("ArmPos", armPos);
         telemetry.addData("ArmTarget", target);
         telemetry.addData("PID Output", armPidOutput);
         telemetry.addData("Motor armPower", armPower);

         telemetry.addData("x",robot.pose.x);
         telemetry.addData("y",robot.pose.y);
         telemetry.addData("h",robot.pose.h);
         telemetry.addData("heading",robot.getHeading());

         telemetry.addData("ms", (currentTime-lastTime)/1E6);
         telemetry.addData("lf", (currentLF-lastLF)/loopTime);
         telemetry.addData("lb", (currentRF-lastRF)/loopTime);
         telemetry.addData("lf", (currentLB-lastLB)/loopTime);
         telemetry.addData("lf", (currentRB-lastRB)/loopTime);
         lastLF = currentLF;

         telemetry.update();
      }
   }

   public void extensionIn() {
      armExtension2.setPower(-1);
      armExtension1.setPower(-1);
      climbHook.setPower(0);
      waitFor(800);
      }

   public void stopExtension(){
      armExtension2.setPower(0);
      armExtension1.setPower(0);
   }

   public void waitFor(long milliseconds){

      timer.reset();  // Reset the timer
      while (opModeIsActive() && timer.milliseconds() < milliseconds) {
         runArmPID();  // Keep PID running
         telemetry.update();  // Keep telemetry updating
      }
   }

   public void servoOut() {
      climbServo.setPosition(0.275);// this is the perfect down position
   }

   public void firstAscent() {
      servoOut();
      climbHook.setPower(1.0);
       target=157;
      newTarget=157;
      waitFor(1100);
   }
   public void fullExtension(){
      armExtension1.setPower(1);// extend
      armExtension2.setPower(1);
      waitFor(1100);
       armExtension1.setPower(0);// stop
      armExtension2.setPower(0);
   }

   public void retractToHook(){
      armExtension1.setPower(-1);
      armExtension2.setPower(-1);
   }

   public void ClimbHookRelease() {
      climbHook.setPower(-1);
      waitFor(200);
      climbHook.setPower(0.1);
   }

   public void fullRetraction() {
      armExtension1.setPower(-1);
      armExtension2.setPower(-1);
      waitFor(2000);
      setArmTarget(-23);
      target=-23;
      newTarget=-23;
      waitFor(3000);
      armExtension1.setPower(0);
      armExtension2.setPower(0);
   }

   public void holdPosition() {
      waitFor(1000000000);
   }


   public void setArmTarget(double newTarget) {
      target = newTarget;
   }

   public void runArmPID() {
      double armPos = -armPivot.getCurrentPosition() / ticks_in_degree;
      double pidOutput = armController.calculate(armPos, target);
      double ff = Math.cos(Math.toRadians(armPos)) * f;
      double power = pidOutput + ff;

      power = Math.max(-0.4, Math.min(1.0, power));

      armPivot.setPower(power);

      telemetry.addData("ArmPos", armPos);
      telemetry.addData("ArmTarget", target);
      telemetry.addData("PID Output", pidOutput);
      telemetry.addData("Feedforward", ff);
      telemetry.addData("Motor Power", power);
   }


   public void waitForArmToReachTarget() {
      double armPos = -armPivot.getCurrentPosition() / ticks_in_degree;
      while (Math.abs(armPos - target) > 5) {
         runArmPID();
         armPos = -armPivot.getCurrentPosition() / ticks_in_degree;
         telemetry.update();
      }
      runArmPID();
      telemetry.addData("Arm reached target", target);
   }



}
